# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2024 Valory AG
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains the implemenatation of the PoolBehaviour interface."""

from abc import ABC, abstractmethod
from typing import Any, Dict, Generator

from aea.configurations.data_types import PublicId

from packages.valory.protocols.contract_api import ContractApiMessage
from packages.valory.skills.abstract_round_abci.behaviours import BaseBehaviour


WaitableConditionType = Generator[None, None, Any]


class PoolBehaviour(BaseBehaviour, ABC):
    """PoolBehaviour"""

    def __init__(self, **kwargs: Any) -> None:
        """Initialize `PoolBehaviour`."""
        super().__init__(**kwargs)

    @abstractmethod
    def _get_tokens(self) -> Dict[str, str]:
        """Get the pool tokens"""
        pass

    @abstractmethod
    def enter(self, **kwargs: Any) -> Generator[None, None, str]:
        """Enter pool"""
        pass

    @abstractmethod
    def exit(self, **kwargs: Any) -> None:
        """Exit pool"""
        pass

    def default_error(
        self, contract_id: str, contract_callable: str, response_msg: ContractApiMessage
    ) -> None:
        """Return a default contract interaction error message."""
        self.context.logger.error(
            f"Could not successfully interact with the {contract_id} contract "
            f"using {contract_callable!r}: {response_msg}"
        )

    def contract_interaction_error(
        self, contract_id: str, contract_callable: str, response_msg: ContractApiMessage
    ) -> None:
        """Return a contract interaction error message."""
        # contracts can only return one message, i.e., multiple levels cannot exist.
        for level in ("info", "warning", "error"):
            msg = response_msg.raw_transaction.body.get(level, None)
            logger = getattr(self.context.logger, level)
            if msg is not None:
                logger(msg)
                return

        self.default_error(contract_id, contract_callable, response_msg)

    def contract_interact(
        self,
        performative: ContractApiMessage.Performative,
        contract_address: str,
        contract_public_id: PublicId,
        contract_callable: str,
        data_key: str,
        **kwargs: Any,
    ) -> WaitableConditionType:
        """Interact with a contract."""
        contract_id = str(contract_public_id)

        self.context.logger.info(
            f"Interacting with contract {contract_id} at address {contract_address}"
        )
        self.context.logger.debug(
            f"Calling method '{contract_callable}' with parameters: {kwargs}"
        )

        try:
            response_msg = yield from self.get_contract_api_response(
                performative,
                contract_address,
                contract_id,
                contract_callable,
                **kwargs,
            )
            self.context.logger.debug(f"Received response message: {response_msg}")

            if response_msg.performative != ContractApiMessage.Performative.RAW_TRANSACTION:
                self.default_error(contract_id, contract_callable, response_msg)
                return None

            data = response_msg.raw_transaction.body.get(data_key)
            if data is None:
                self.contract_interaction_error(contract_id, contract_callable, response_msg)
                return None

            self.context.logger.info(f"Successfully retrieved data: {data}")
            return data

        except Exception as e:
            self.context.logger.error(f"Exception during contract interaction: {e}")
            return None
        
    def async_act(self) -> Generator[Any, None, None]:
        """Async act"""
        pass
